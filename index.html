<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Artificial Life Simulator ‚Äî Research Batch Mode (Dark)</title>
  <!-- Tailwind via CDN (play) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Tailwind base is loaded; add small customizations */
    :root { --bg:#0b0f14; --card:#0f1720; --muted:#94a3b8; }
    body { background: linear-gradient(180deg,#05070a 0%, #0b0f14 100%); color: #e6eef8; }
    .card { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); }
    /* canvas pixel crisp */
    canvas { image-rendering: pixelated; }
    /* small responsive tweaks */
    .sidebar { max-height: calc(100vh - 160px); overflow:auto; }
    .graph-area { height: 220px; }
  </style>
  <!-- Chart.js for graphs -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="min-h-screen font-sans">
  <div class="max-w-screen-2xl mx-auto p-4">
    <header class="flex items-center justify-between mb-4">
      <h1 class="text-2xl font-semibold">Artificial Life Simulator <span class="text-sm text-gray-400">(Research / Batch Mode) ‚Äî Dark</span></h1>
      <div class="flex gap-2 items-center">
        <button id="startBtn" class="px-3 py-1 bg-green-600 rounded hover:opacity-90">‚ñ∂ Start</button>
        <button id="stopBtn" class="px-3 py-1 bg-yellow-600 rounded hover:opacity-90">‚è∏ Stop</button>
        <button id="resetBtn" class="px-3 py-1 bg-red-600 rounded hover:opacity-90">‚ü≤ Reset</button>
        <button id="runBatchBtn" class="px-3 py-1 bg-sky-600 rounded hover:opacity-90">üìä Run Batch</button>
      </div>
    </header>

    <main class="grid grid-cols-3 gap-4">
      <!-- Left: Canvas / Visualization -->
      <section class="col-span-2 card p-3 rounded-lg">
        <div class="flex items-center justify-between mb-2">
          <div class="text-sm text-gray-300">Visualization</div>
          <div class="flex items-center gap-2">
            <label class="text-xs text-gray-400">Mode</label>
            <select id="modeSelect" class="text-black text-sm rounded px-1">
              <option value="realtime">Realtime</option>
              <option value="fast">Fast (reduced draw)</option>
              <option value="off">Off (batch)</option>
            </select>
            <label class="text-xs text-gray-400">Draw Grid</label>
            <input id="drawGrid" type="checkbox" checked />
          </div>
        </div>
        <div class="w-full h-[520px] bg-[#071019] rounded flex items-center justify-center">
          <canvas id="worldCanvas" width="800" height="520" class="rounded"></canvas>
        </div>

        <div class="mt-3 grid grid-cols-2 gap-3">
          <div class="card p-3 rounded">
            <div class="text-xs text-gray-400 mb-1">Grass Population</div>
            <div class="graph-area"><canvas id="grassChart"></canvas></div>
          </div>
          <div class="card p-3 rounded">
            <div class="text-xs text-gray-400 mb-1">Animal Population</div>
            <div class="graph-area"><canvas id="animalChart"></canvas></div>
          </div>
        </div>
      </section>

      <!-- Right: Controls / Params / Batch -->
      <aside class="card p-3 rounded-lg sidebar">
        <h2 class="text-lg mb-2">Parameters</h2>
        <div class="grid grid-cols-2 gap-2 text-sm">
          <label class="col-span-1">Grid N</label>
          <input id="paramN" type="number" value="80" min="10" max="500" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Cell size (px)</label>
          <input id="paramCell" type="number" value="8" min="2" max="40" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Grass growth period</label>
          <input id="paramGrassPeriod" type="number" value="5" min="1" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Initial grass count</label>
          <input id="paramGrassInit" type="number" value="640" min="0" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Initial animals</label>
          <input id="paramAnimalInit" type="number" value="128" min="0" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Animal initial HP</label>
          <input id="paramHP" type="number" value="10" min="1" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Eat recovery</label>
          <input id="paramRecover" type="number" value="5" min="0" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Reproduction threshold</label>
          <input id="paramRepro" type="number" value="12" min="0" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Fullness threshold</label>
          <input id="paramFull" type="number" value="15" min="0" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Post-repro parent HP</label>
          <input id="paramParentAfter" type="number" value="7" min="0" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Lifespan (turns)</label>
          <input id="paramLifespan" type="number" value="200" min="1" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Turn interval (ms)</label>
          <input id="paramInterval" type="number" value="200" min="10" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Seed (0 = random)</label>
          <input id="paramSeed" type="number" value="0" min="0" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Intelligence (grass-priority)</label>
          <select id="paramSmart" class="bg-[#0b1220] p-1 rounded text-white">
            <option value="1">ON</option>
            <option value="0">OFF</option>
          </select>

          <label>Draw sample step (graph)</label>
          <input id="paramGraphSample" type="number" value="1" min="1" class="bg-[#0b1220] p-1 rounded text-white" />

          <label>Max grid recommended</label>
          <div class="text-xs text-gray-400">200 (500 max, heavy)</div>
        </div>

        <div class="mt-3 border-t pt-3">
          <h3 class="text-sm mb-1">Batch Runner</h3>
          <label class="text-xs text-gray-400">Trials</label>
          <input id="batchTrials" type="number" value="50" min="1" class="bg-[#0b1220] p-1 rounded text-white w-full" />
          <label class="text-xs text-gray-400 mt-2">Max turns per trial</label>
          <input id="batchMaxTurns" type="number" value="2000" min="1" class="bg-[#0b1220] p-1 rounded text-white w-full" />
          <label class="text-xs text-gray-400 mt-2">Auto-download CSV on finish</label>
          <input id="batchAutoDL" type="checkbox"/>
          <div class="mt-2 flex gap-2">
            <button id="startBatchBtn" class="px-3 py-1 bg-indigo-600 rounded">‚ñ∂ Run Batch</button>
            <button id="abortBatchBtn" class="px-3 py-1 bg-gray-600 rounded">‚úñ Abort</button>
            <button id="exportPresetBtn" class="px-3 py-1 bg-emerald-600 rounded">üíæ Export Preset</button>
          </div>
        </div>

        <div class="mt-3 border-t pt-3 text-sm">
          <h3 class="mb-1">Batch Results (summary)</h3>
          <div id="batchSummary" class="text-xs text-gray-300">No runs yet.</div>
          <div id="batchTable" class="mt-2 text-xs"></div>
        </div>
      </aside>
    </main>

    <footer class="mt-4 text-xs text-gray-400">Notes: Red circle = animal, Green = grass. Batch mode disables drawing for speed.</footer>
  </div>

  <script>
  /***************************************************************************
   * Artificial Life Simulator: Single-file implementation
   * - Dark theme UI
   * - Realtime visualization + Batch runner
   * - Core engine separated and can run without rendering for high-speed batch
   * - PRNG: mulberry32 for reproducibility
   * ***************************************************************************/

  // --------------------------- Utility: PRNG (mulberry32) --------------------
  function mulberry32(a) {
    return function() {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  // --------------------------- Core Simulation Engine -----------------------
  class Simulator {
    constructor(params, rng) {
      this.params = Object.assign({}, params);
      this.rng = rng; // function returning [0,1)

      this.reset();
    }

    reset() {
      const p = this.params;
      this.turn = 0;
      this.gridN = p.N;
      this.cellCount = p.N * p.N;
      // grid representation: grass boolean array, animal id array (-1 none)
      this.grass = new Uint8Array(this.cellCount); // 0/1
      this.animalAt = new Int32Array(this.cellCount); // -1 none or index
      this.animals = []; // list of animal objects
      this.nextAnimalId = 0;

      for (let i=0;i<this.cellCount;i++){ this.animalAt[i] = -1; }

      // initial placements (random without overlap for animals)
      // prepare list of indices
      const indices = Array.from({length:this.cellCount}, (_,i)=>i);
      shuffleArray(indices, this.rng);

      // place grass
      let gcount = Math.min(this.params.grassInit, this.cellCount);
      for (let i=0;i<gcount;i++){ this.grass[indices[i]] = 1; }

      // place animals on remaining random empty cells (animals cannot share)
      let ai = 0;
      for (let j=gcount; ai < this.params.animalInit && (gcount + ai) < this.cellCount; j++){
        const idx = indices[j];
        // place animal
        const a = this._createAnimal(idx);
        this.animals.push(a);
        this.animalAt[idx] = a.id;
        ai++;
      }
    }

    _createAnimal(cellIndex){
      const a = {
        id: this.nextAnimalId++,
        cell: cellIndex,
        hp: this.params.hpInit,
        age: 0,
        alive: true,
        bornThisTurn: true, // will be set false at end of turn
      };
      return a;
    }

    // helper: convert (r,c) <-> index
    idxToRC(i){ return [Math.floor(i/this.gridN), i % this.gridN]; }
    rcToIdx(r,c){ return r * this.gridN + c; }

    inBounds(r,c){ return r>=0 && c>=0 && r < this.gridN && c < this.gridN; }

    getNeighbors(idx){
      const N = this.gridN;
      const r = Math.floor(idx / N);
      const c = idx % N;
      const out=[];
      if (r>0) out.push(idx - N);
      if (r < N-1) out.push(idx + N);
      if (c>0) out.push(idx -1);
      if (c < N-1) out.push(idx +1);
      return out;
    }

    stepOneTurn() {
      // core pipeline according to spec:
      // 1) movement decisions (with retries on conflicts)
      // 2) apply movement outcomes
      // 3) eating
      // 4) reproduction
      // 5) natural decrease
      // 6) age++, death by hp<=0 or age>=lifespan

      const Nanimals = this.animals.length;
      // index alive map
      const aliveAnimals = this.animals.filter(a=>a.alive);

      // DECISION PHASE
      // For each animal, decide a desired move (or null for stay)
      const desiredMove = new Map(); // animalId -> targetCell or null
      const moveRequests = new Map(); // cell -> array of animalIds requesting

      for (const a of aliveAnimals){
        if (a.bornThisTurn) { desiredMove.set(a.id, a.cell); continue; } // newborn don't act this turn
        // choose movement candidate
        const neigh = this.getNeighbors(a.cell);
        // build candidate list excluding occupied cells
        let candidates = neigh.filter(ci => this.animalAt[ci] === -1);
        // if intelligence on, prefer grass neighbors
        if (this.params.smart) {
          const grassNeighbors = candidates.filter(ci => this.grass[ci]);
          if (grassNeighbors.length > 0) candidates = grassNeighbors;
        }
        // if no candidates (all occupied or no neighbor due to border), animal stays
        if (candidates.length === 0) { desiredMove.set(a.id, a.cell); continue; }
        // choose random one
        const pick = candidates[Math.floor(this.rng() * candidates.length)];
        desiredMove.set(a.id, pick);
        if (!moveRequests.has(pick)) moveRequests.set(pick, []);
        moveRequests.get(pick).push(a.id);
      }

      // RESOLUTION PHASE: movement conflicts
      // We'll process each requested cell: allow one random animal, other animals attempt retries
      const finalMove = new Map(); // animalId -> final cell

      // initialize all to current cell
      for (const a of aliveAnimals) finalMove.set(a.id, a.cell);

      // temporary occupancy for resolution (start with current occupancy)
      const occ = new Int32Array(this.cellCount);
      for (let i=0;i<this.cellCount;i++) occ[i] = this.animalAt[i];

      // process requests in random order of cells to avoid bias
      const requestedCells = Array.from(moveRequests.keys());
      shuffleArray(requestedCells, this.rng);

      for (const cell of requestedCells){
        const reqs = moveRequests.get(cell);
        // filter alive and those that still haven't moved
        const validReqs = reqs.filter(id => {
          const a = this.animals.find(x=>x.id===id);
          return a && a.alive;
        });
        if (validReqs.length === 0) continue;
        // if cell currently free in occ
        if (occ[cell] === -1){
          // pick one randomly to succeed
          const winner = validReqs[Math.floor(this.rng()*validReqs.length)];
          finalMove.set(winner, cell);
          occ[cell] = winner;
          // losers will retry
          const losers = validReqs.filter(id => id !== winner);
          for (const lid of losers){
            // retry up to 3 additional attempts (total up to 4 including original)
            const a = this.animals.find(x=>x.id===lid);
            let placed = false;
            const neigh = this.getNeighbors(a.cell);
            // build candidate list excluding occupied cells and excluding original requested
            const pool = shuffleArray(neigh.filter(ci => occ[ci] === -1 && ci !== cell), this.rng);
            for (let attempt=0; attempt < pool.length && attempt < 3; attempt++){
              const candidate = pool[attempt];
              if (occ[candidate] === -1){ finalMove.set(lid, candidate); occ[candidate] = lid; placed = true; break; }
            }
            if (!placed){ finalMove.set(lid, a.cell); }
          }
        } else {
          // cell already occupied by someone who won't move; all requesters retry
          for (const lid of validReqs){
            const a = this.animals.find(x=>x.id===lid);
            let placed = false;
            const neigh = this.getNeighbors(a.cell);
            const pool = shuffleArray(neigh.filter(ci => occ[ci] === -1), this.rng);
            for (let attempt=0; attempt < pool.length && attempt < 3; attempt++){
              const candidate = pool[attempt];
              if (occ[candidate] === -1){ finalMove.set(lid, candidate); occ[candidate] = lid; placed = true; break; }
            }
            if (!placed){ finalMove.set(lid, a.cell); }
          }
        }
      }

      // now apply movements: clear animalAt and reassign
      for (let i=0;i<this.cellCount;i++) this.animalAt[i] = -1;
      for (const a of aliveAnimals){
        const dest = finalMove.get(a.id) ?? a.cell;
        a.cell = dest;
        this.animalAt[dest] = a.id;
      }

      // EATING PHASE
      for (const a of aliveAnimals){
        if (a.bornThisTurn) continue; // newborn don't act
        // if fullness (hp > full threshold) then don't eat
        if (a.hp > this.params.fullThreshold) continue;
        if (this.grass[a.cell]){
          // eat
          this.grass[a.cell] = 0;
          a.hp += this.params.recover;
        }
      }

      // REPRODUCTION PHASE
      // each animal with hp >= repro tries to find an adjacent empty cell (animalAt == -1)
      // if multiple animals attempt same cell, reproduction fails for those attempts (as per spec)
      const reproRequests = new Map(); // cell -> array of animal ids attempting
      for (const a of aliveAnimals){
        if (a.bornThisTurn) continue;
        if (a.hp >= this.params.reproThreshold){
          const neigh = this.getNeighbors(a.cell);
          const empties = neigh.filter(ci => this.animalAt[ci] === -1);
          if (empties.length === 0) continue; // fail
          const pick = empties[Math.floor(this.rng() * empties.length)];
          if (!reproRequests.has(pick)) reproRequests.set(pick, []);
          reproRequests.get(pick).push(a.id);
        }
      }

      // resolve repro: if exactly one requester for a cell -> success, otherwise failure
      const newAnimals = [];
      for (const [cell, reqs] of reproRequests.entries()){
        if (reqs.length !== 1) continue; // fail
        const parentId = reqs[0];
        const parent = this.animals.find(x=>x.id===parentId);
        if (!parent || !parent.alive) continue;
        // create child
        const child = this._createAnimal(cell);
        child.hp = this.params.hpInit;
        child.bornThisTurn = true;
        newAnimals.push(child);
        // place child in map; but it should not act until next turn
        this.animalAt[cell] = child.id;
        // parent HP set to post-repro value
        parent.hp = this.params.parentAfter;
      }

      // add new animals to list
      for (const c of newAnimals){ this.animals.push(c); }

      // NATURAL DECREASE
      for (const a of aliveAnimals){
        if (a.bornThisTurn) continue; // newborn not affected? spec said natural -1 every turn; assume newborn still suffer next turn
        a.hp -= 1;
      }

      // AGE & DEATH
      for (const a of this.animals){
        if (!a.alive) continue;
        // newborn flag reset at end of this turn
        a.bornThisTurn = false;
      }

      for (const a of this.animals){
        if (!a.alive) continue;
        a.age += 1; // age increment at turn end
        if (a.hp <= 0 || a.age >= this.params.lifespan) {
          // remove
          a.alive = false;
          if (this.animalAt[a.cell] === a.id) this.animalAt[a.cell] = -1;
        }
      }

      // GRASS GROWTH: per user choice, after animal processing
      if (this.turn % this.params.grassPeriod === 0){
        // attempt growth from every grass cell? Spec: "grass globally attempts to spread simultaneously".
        // We'll iterate through all grass cells as sources (snapshot) and each tries to grow into a random empty neighbor
        const sources = [];
        for (let i=0;i<this.cellCount;i++) if (this.grass[i]) sources.push(i);
        // shuffle to avoid bias
        shuffleArray(sources, this.rng);
        const grassAdd = [];
        for (const s of sources){
          const neigh = this.getNeighbors(s).filter(ci => !this.grass[ci]);
          if (neigh.length === 0) continue;
          const pick = neigh[Math.floor(this.rng() * neigh.length)];
          grassAdd.push(pick);
        }
        // apply growth, but cell becomes grass even if animal present (coexist allowed)
        for (const g of grassAdd) this.grass[g] = 1;
      }

      this.turn += 1;

      // housekeeping: remove dead animals from list occasionally to keep array small
      if (this.turn % 100 === 0){ this.animals = this.animals.filter(a=>a.alive); }

      // return summary counts and flags for external usage
      const grassCount = this.grass.reduce((s,v)=>s+v,0);
      const animalCount = this.animals.filter(a=>a.alive).length;
      return { turn: this.turn, grassCount, animalCount };
    }

  }

  // -------------------- helpers --------------------
  function shuffleArray(arr, rng){
    // Fisher-Yates
    for (let i = arr.length -1; i>0; i--){
      const j = Math.floor(rng() * (i+1));
      const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
    }
    return arr;
  }

  // ------------------ UI & Integration ------------------
  // Grab DOM
  const canvas = document.getElementById('worldCanvas');
  const ctx = canvas.getContext('2d');

  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const resetBtn = document.getElementById('resetBtn');
  const runBatchBtn = document.getElementById('runBatchBtn');

  const startBatchBtn = document.getElementById('startBatchBtn');
  const abortBatchBtn = document.getElementById('abortBatchBtn');
  const batchSummary = document.getElementById('batchSummary');
  const batchTable = document.getElementById('batchTable');

  // charts
  const grassCtx = document.getElementById('grassChart').getContext('2d');
  const animalCtx = document.getElementById('animalChart').getContext('2d');

  let grassChart = null, animalChart = null;

  function createCharts(){
    if (grassChart) grassChart.destroy();
    if (animalChart) animalChart.destroy();
    grassChart = new Chart(grassCtx, {
      type:'line', data:{ labels:[], datasets:[{ label:'Grass', data:[] , borderWidth:1, tension:0.2}]}, options:{ plugins:{ legend:{ display:false } }, animation:false, scales:{ x:{ display:false } }}
    });
    animalChart = new Chart(animalCtx, {
      type:'line', data:{ labels:[], datasets:[{ label:'Animals', data:[], borderWidth:1, tension:0.2}]}, options:{ plugins:{ legend:{ display:false } }, animation:false, scales:{ x:{ display:false } }}
    });
  }
  createCharts();

  // state
  let sim = null;
  let simRng = null;
  let intervalHandle = null;
  let running = false;

  function readParamsFromUI(){
    const p = {};
    p.N = parseInt(document.getElementById('paramN').value);
    p.cellSize = parseInt(document.getElementById('paramCell').value);
    p.grassPeriod = parseInt(document.getElementById('paramGrassPeriod').value);
    p.grassInit = parseInt(document.getElementById('paramGrassInit').value);
    p.animalInit = parseInt(document.getElementById('paramAnimalInit').value);
    p.hpInit = parseInt(document.getElementById('paramHP').value);
    p.recover = parseInt(document.getElementById('paramRecover').value);
    p.reproThreshold = parseInt(document.getElementById('paramRepro').value);
    p.fullThreshold = parseInt(document.getElementById('paramFull').value);
    p.parentAfter = parseInt(document.getElementById('paramParentAfter').value);
    p.lifespan = parseInt(document.getElementById('paramLifespan').value);
    p.interval = parseInt(document.getElementById('paramInterval').value);
    p.seed = parseInt(document.getElementById('paramSeed').value);
    p.smart = parseInt(document.getElementById('paramSmart').value) === 1;
    p.graphSample = parseInt(document.getElementById('paramGraphSample').value) || 1;
    return p;
  }

  function initSimulationFromUI(){
    const ui = readParamsFromUI();
    // normalize some params
    const seed = (ui.seed === 0) ? Math.floor(Math.random()*0xFFFFFFFF) : ui.seed;
    simRng = mulberry32(seed);
    const params = {
      N: ui.N,
      grassPeriod: ui.grassPeriod,
      grassInit: ui.grassInit,
      animalInit: ui.animalInit,
      hpInit: ui.hpInit,
      recover: ui.recover,
      reproThreshold: ui.reproThreshold,
      fullThreshold: ui.fullThreshold,
      parentAfter: ui.parentAfter,
      lifespan: ui.lifespan,
      smart: ui.smart
    };
    sim = new Simulator(params, simRng);
    // override interval
    sim.interval = ui.interval;

    // set canvas size according to grid and cellSize
    const cw = Math.min(1200, ui.N * ui.cellSize);
    const ch = Math.min(520, ui.N * ui.cellSize);
    canvas.width = cw; canvas.height = ch;

    // rerender charts
    createCharts();

    // initial draw
    drawWorld();
    // initial chart points
    updateCharts(sim.turn, sim.grass.reduce((s,v)=>s+v,0), sim.animals.filter(a=>a.alive).length, true);
  }

  // DRAWING
  function drawWorld(){
    if (!sim) return;
    const p = readParamsFromUI();
    const ctx = canvas.getContext('2d');
    // background
    ctx.fillStyle = '#071019'; ctx.fillRect(0,0,canvas.width,canvas.height);

    const N = sim.gridN;
    const cellSize = p.cellSize;
    // compute offset to center if large
    const totalW = N * cellSize;
    const totalH = N * cellSize;
    const ox = Math.max(0, (canvas.width - totalW)/2);
    const oy = Math.max(0, (canvas.height - totalH)/2);

    // draw grass
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        const idx = r*N + c;
        if (sim.grass[idx]){
          ctx.fillStyle = '#0bbf53';
          ctx.fillRect(ox + c*cellSize, oy + r*cellSize, cellSize, cellSize);
        }
      }
    }
    // draw animals as red circles
    for (const a of sim.animals){
      if (!a.alive) continue;
      const r = Math.floor(a.cell / N); const c = a.cell % N;
      const x = ox + c*cellSize + cellSize/2;
      const y = oy + r*cellSize + cellSize/2;
      const radius = Math.max(1, Math.min(cellSize/2 - 1, cellSize*0.4));
      ctx.beginPath(); ctx.fillStyle = '#ff4d4f'; ctx.arc(x,y,radius,0,Math.PI*2); ctx.fill();
    }
    // draw grid optionally
    const drawGrid = document.getElementById('drawGrid').checked;
    if (drawGrid){ ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.lineWidth=1; for (let r=0;r<=N;r++){ ctx.beginPath(); ctx.moveTo(ox, oy + r*cellSize); ctx.lineTo(ox + totalW, oy + r*cellSize); ctx.stroke(); } for (let c=0;c<=N;c++){ ctx.beginPath(); ctx.moveTo(ox + c*cellSize, oy); ctx.lineTo(ox + c*cellSize, oy + totalH); ctx.stroke(); } }
  }

  // CHARTS update
  let lastSample = 0;
  function updateCharts(turn, grassCount, animalCount, force){
    const sample = parseInt(document.getElementById('paramGraphSample').value) || 1;
    if (!force && (turn - lastSample) < sample) return;
    lastSample = turn;
    grassChart.data.labels.push(turn);
    grassChart.data.datasets[0].data.push(grassCount);
    grassChart.update();
    animalChart.data.labels.push(turn);
    animalChart.data.datasets[0].data.push(animalCount);
    animalChart.update();
  }

  // MAIN loop control
  function startSimulation(){
    if (!sim) initSimulationFromUI();
    if (running) return; running = true;
    const mode = document.getElementById('modeSelect').value;
    const intervalMs = parseInt(document.getElementById('paramInterval').value) || 200;

    if (mode === 'off'){
      // do nothing in realtime: user should use batch for off
      running = false; return;
    }

    if (mode === 'fast'){
      // run many steps without drawing to speed up
      intervalHandle = setInterval(() => {
        for (let i=0;i<5;i++){
          const s = sim.stepOneTurn();
        }
        drawWorld(); updateCharts(sim.turn, sim.grass.reduce((s,v)=>s+v,0), sim.animals.filter(a=>a.alive).length);
      }, Math.max(10, intervalMs));
    } else {
      intervalHandle = setInterval(() => {
        const s = sim.stepOneTurn();
        drawWorld(); updateCharts(sim.turn, s.grassCount, s.animalCount);
      }, Math.max(10, intervalMs));
    }
  }

  function stopSimulation(){ if (intervalHandle) clearInterval(intervalHandle); intervalHandle = null; running = false; }

  function resetSimulation(){ stopSimulation(); initSimulationFromUI(); }

  // BATCH runner (synchronous but with yields to UI)
  let batchAbort = false;
  async function runBatch(trials, maxTurns, autoDL){
    batchAbort = false;
    const uiParams = readParamsFromUI();
    const results = [];
    const startTime = Date.now();
    for (let t=0;t<trials;t++){
      if (batchAbort) break;
      // set a fresh seed for each run
      const baseSeed = uiParams.seed === 0 ? Math.floor(Math.random()*0xFFFFFFFF) : uiParams.seed;
      const runSeed = (baseSeed + t) >>> 0;
      const rng = mulberry32(runSeed);
      const params = {
        N: uiParams.N,
        grassPeriod: uiParams.grassPeriod,
        grassInit: uiParams.grassInit,
        animalInit: uiParams.animalInit,
        hpInit: uiParams.hpInit,
        recover: uiParams.recover,
        reproThreshold: uiParams.reproThreshold,
        fullThreshold: uiParams.fullThreshold,
        parentAfter: uiParams.parentAfter,
        lifespan: uiParams.lifespan,
        smart: uiParams.smart
      };
      const s = new Simulator(params, rng);
      let grassExtinctTurn = null; let animalExtinctTurn = null;

      for (let step=0; step<maxTurns; step++){
        const summary = s.stepOneTurn();
        if (summary.grassCount === 0 && grassExtinctTurn === null) grassExtinctTurn = summary.turn;
        if (summary.animalCount === 0 && animalExtinctTurn === null) animalExtinctTurn = summary.turn;
        if (summary.turn % 200 === 0) await sleep(0); // yield to UI
        if (summary.turn >= maxTurns) break;
        if (summary.animalCount === 0 && summary.grassCount === 0) break; // both extinct
      }
      const final = {
        trial: t+1,
        seed: runSeed,
        final_grass: s.grass.reduce((ac, v) => ac + v, 0),
        final_animals: s.animals.filter(a=>a.alive).length,
        grass_extinct_turn: grassExtinctTurn === null ? 'NA' : grassExtinctTurn,
        animal_extinct_turn: animalExtinctTurn === null ? 'NA' : animalExtinctTurn,
        total_turns: s.turn
      };
      results.push(final);
      // update UI summary intermittently
      if ((t+1) % Math.max(1, Math.floor(trials/10)) === 0){ updateBatchUI(results); await sleep(0); }
    }
    const elapsed = (Date.now() - startTime)/1000;
    batchSummary.innerText = `Completed ${results.length}/${trials} trials in ${elapsed.toFixed(2)}s.`;
    updateBatchUI(results);
    if (autoDL) downloadCSV(results, 'batch_results.csv');
    return results;
  }

  function updateBatchUI(results){
    if (results.length === 0){ batchTable.innerHTML = '<div class="text-gray-400">No results</div>'; return; }
    // compute averages
    const avg = results.reduce((acc,r)=>{ acc.final_grass += r.final_grass; acc.final_animals += r.final_animals; acc.total_turns += r.total_turns; return acc; }, {final_grass:0, final_animals:0, total_turns:0});
    avg.final_grass = (avg.final_grass / results.length).toFixed(2);
    avg.final_animals = (avg.final_animals / results.length).toFixed(2);
    avg.total_turns = (avg.total_turns / results.length).toFixed(2);
    const extinctAnimalCount = results.filter(r => r.animal_extinct_turn !== 'NA').length;
    const extinctAnimalProb = (extinctAnimalCount / results.length * 100).toFixed(1);
    const avgAnimalExtinctTurn = (
      results.reduce((acc, r) => {
      const turn = (r.animal_extinct_turn === 'NA') ? 1000 : r.animal_extinct_turn;
      return acc + turn;
      }, 0) / results.length
    ).toFixed(1);
    let html = `<div>Trials: ${results.length}</div><div>Avg grass: ${avg.final_grass} | Avg animals: ${avg.final_animals} | Avg turns: ${avg.total_turns}| Animal extinction: ${extinctAnimalProb}%</div><div>Average animal extinction turn: ${avgAnimalExtinctTurn}</div>`;
    html += '<div class="mt-2 overflow-auto max-h-48"><table class="text-xs w-full"><thead><tr><th>#</th><th>seed</th><th>final_grass</th><th>final_animals</th><th>grass_extinct</th><th>animal_extinct</th><th>turns</th></tr></thead><tbody>';
    for (const r of results){ html += `<tr><td>${r.trial}</td><td>${r.seed}</td><td>${r.final_grass}</td><td>${r.final_animals}</td><td>${r.grass_extinct_turn}</td><td>${r.animal_extinct_turn}</td><td>${r.total_turns}</td></tr>`; }
    html += '</tbody></table></div>';
    batchTable.innerHTML = html;
  }

  function downloadCSV(rows, filename){
    const header = ['trial','seed','final_grass','final_animals','grass_extinct_turn','animal_extinct_turn','total_turns'];
    const lines = [header.join(',')];
    for (const r of rows){ lines.push([r.trial, r.seed, r.final_grass, r.final_animals, r.grass_extinct_turn, r.animal_extinct_turn, r.total_turns].join(',')); }
    const blob = new Blob([lines.join('\n')], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url);
  }

  function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

  // Event wiring
  startBtn.addEventListener('click', ()=>{ startSimulation(); });
  stopBtn.addEventListener('click', ()=>{ stopSimulation(); });
  resetBtn.addEventListener('click', ()=>{ resetSimulation(); });
  runBatchBtn.addEventListener('click', ()=>{ document.getElementById('modeSelect').value='off'; alert('Switching to batch runner panel (use Run Batch inside right panel).'); });

  startBatchBtn.addEventListener('click', async ()=>{
    stopSimulation();
    const trials = parseInt(document.getElementById('batchTrials').value) || 1;
    const maxTurns = parseInt(document.getElementById('batchMaxTurns').value) || 1000;
    const autoDL = document.getElementById('batchAutoDL').checked;
    batchSummary.innerText = `Running ${trials} trials...`;
    const results = await runBatch(trials, maxTurns, autoDL);
  });

  abortBatchBtn.addEventListener('click', ()=>{ batchAbort = true; batchSummary.innerText = 'Abort requested...'; });

  // export preset
  document.getElementById('exportPresetBtn').addEventListener('click', ()=>{
    const p = readParamsFromUI();
    const blob = new Blob([JSON.stringify(p, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'als_preset.json'; a.click(); URL.revokeObjectURL(url);
  });

  // small helper to recompute charts/draw when params change
  const inputs = document.querySelectorAll('#paramN, #paramCell, #paramGrassPeriod, #paramGrassInit, #paramAnimalInit, #paramHP, #paramRecover, #paramRepro, #paramFull, #paramParentAfter, #paramLifespan, #paramInterval, #paramSeed, #paramSmart');
  inputs.forEach(inp => inp.addEventListener('change', ()=>{ initSimulationFromUI(); }));

  // init default
  initSimulationFromUI();

  </script>
</body>
</html>
